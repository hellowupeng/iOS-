## @property后面可以有哪些修饰符？

Objective-C 属性拥有四种类型的特性。

读写特性：readwrite，readonly；用于指定存取方法名的特性： getter，setter；原子性：atomic，nonatomic；内存管理特性：strong，weak，unsafe_unretained，copy。



属性是对对象数据的封装，它控制对对象的值的访问。属性的本质是：实例变量+存取方法。比如我们声明一个属性 a，编译器会自动合成实例变量：_a，存方法：setA()，取方法：a()。

通过 synthesize 关键字可以自定义合成的实例变量名。

开始提到的四种类型的属性特性用来实现自定义的存取方法。

读写特性默认为 readwrite，编译器会为我们合成存方法和取方法，使用 readonly 修饰的属性编译器只会合成取方法，意味着该属性为只读属性。

getter，setter 特性用于指定自定义的存取方法名。对于布尔型属性，习惯于使用 getter 特性在属性的取方法名前添加 is 前缀。

原子性默认为 atomic，意味着合成的存取方法保证了取方法总是能完整地获取到值，存方法总是能完整地设置值，即使存取方法是从不同的线程同时调用（什么是线程?）。由于 atomic 存取方法的内部实现和同步处理机制是私有的，不能把合成的和自定义的存取方法结合一起。如果这样做了，会得到一个编译器警告。使用 nonatomic 属性就没有这种问题（什么问题？指把合成的和自定义的存取方法结合使用），但是它不能保证从不同线程同时访问的值是一定相同的（为什么？因为没有同步锁）。访问 nonatomic 属性会比 atomic 属性快，atomic 属性的同步锁机制会产生额外的开销。

另外属性的原子特性不意味对象就是线程安全的（为什么？考虑一种情况，一个人的姓和名两个属性从一个线程使用 atomic 存取方法修改它们。如果从另一个线程同时访问这两个属性，atomic 取方法能返回完整的字符串，也不会报错，但是不能保证姓名能正确的对应。有可能姓在改变之前被访问，而名在改变之后被访问）。

内存管理特性默认为 strong，它在实例变量和对象之间声明了一种强引用的所有权关系。对于被引用的对象，只要存在至少一个这种强引用关系，它就会一直呆在内存里而不会被销毁。对于 strong 属性，合成的存方法会保留新值，释放旧值。weak 属性在实例变量和对象之间声明了一种弱引用的关系。一个简单的例子是 tableview 和 delegate 之间互相引用时，通常使用 weak 修饰 delegate 来避免出现强引用循环。对于 weak 属性，合成的存方法既不保留新值，也不释放旧值。为了避免野指针（什么事野指针？）的出现，引用的对象被销毁时，属性会被自动置为 nil。在 Cocoa 和 Cocoa Touch 里有些类不支持 weak 引用（如：NSTextView，NSFont，NSColorSpace），在需要对这些类使用弱引用时，使用 unsafe_unretained 属性。它和弱引用类似，不同之处是引用的对象被销毁后它不会被置为 nil。就会出现一个野指针，所以是不安全的。向野指针发送消息还会导致崩溃。copy 属性和strong一样也会持有一个对象的强引用。不同之处是存方法保留的是新值的一个不可变的副本。使用场景是对于像 NSString、NSArray、NSDictionary 等这样拥有可变子类的类，即使传入存方法的是它的可变子类对象，并在稍后对这个对象的值进行了修改也不会影响 copy 属性引用的对象。