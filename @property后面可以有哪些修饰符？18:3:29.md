## @property后面可以有哪些修饰符？

Objective-C 属性拥有四种类型的特性。

读写特性：readwrite，readonly；用于指定存取方法名的特性： getter，setter；原子性：atomic，nonatomic；内存管理特性：strong，weak，unsafe_unretained，assign，copy。



属性是对对象数据的封装，它控制对对象的值的访问。属性的本质是：实例变量+存取方法。比如我们声明一个属性 a，编译器会自动合成实例变量：_a，存方法：setA()，取方法：a()。

通过 synthesize 关键字可以自定义合成的实例变量名。

开始提到的四种类型的属性特性用来实现自定义的存取方法。

读写特性默认为 readwrite，编译器会为我们合成存方法和取方法，使用 readonly 修饰的属性编译器只会合成取方法，意味着该属性为只读属性。

getter，setter 特性用于指定自定义的存取方法名。对于布尔型属性，习惯于使用 getter 特性在属性的取方法名前添加 is 前缀。

原子性默认为 atomic，意味着合成的存取方法保证了取方法总是能完整地获取到值，存方法总是能完整地设置值，即使存取方法是从不同的线程同时调用（什么是线程？线程是一个计算机术语，用于称呼代码执行的一条独立的路径）。由于 atomic 存取方法的内部实现和同步处理机制是私有的，不能把合成的和自定义的存取方法结合一起使用。如果这样做了，会得到一个编译器警告。使用 nonatomic 属性就没有这种问题（什么问题？指把合成的和自定义的存取方法结合使用），但是它不能保证从不同线程同时访问同一个值不出问题（为什么？因为没有同步锁）。访问 nonatomic 属性会比 atomic 属性快，atomic 属性的同步锁机制会产生额外的开销。

另外属性的原子特性不意味对象就是线程安全的（为什么？考虑一种情况，一个人的姓和名两个属性从一个线程使用 atomic 存取方法修改它们。如果从另一个线程同时访问这两个属性，atomic 取方法能返回完整的字符串，也不会报错，但是不能保证姓名能正确的对应。有可能姓在改变之前被访问，而名在改变之后被访问）。

内存管理特性默认为 strong，它在实例变量和对象之间定义了一种“拥有”的关系，或者说对对象有一个强引用。对于被引用的对象，只要存在至少一个这种强引用关系，它就会一直呆在内存里而不会被销毁。对于 strong 属性，合成的存方法会保留新值，释放旧值（指新值的引用计数会+1，旧值的引用计数会-1）。weak 属性在实例变量和对象之间声明了一种弱引用的关系。一个简单的例子是 tableview 和 delegate 之间互相引用时，通常使用 weak 修饰 delegate 来避免出现强引用循环。对于 weak 属性，合成的存方法既不保留新值，也不释放旧值。为了避免野指针（什么是野指针？）的出现，引用的对象被销毁时，属性会被自动置为 nil。在 Cocoa 和 Cocoa Touch 里有些类不支持 weak 引用（如：NSTextView，NSFont，NSColorSpace），在需要对这些类使用弱引用时，使用 unsafe_unretained 属性。它和弱引用类似，不同之处是引用的对象被销毁后它不会被置为 nil。就会出现一个野指针，所以是不安全的。向野指针发送消息还会导致崩溃。assign 的存方法只会执行针对纯量类型（如CGFloat、NSInteger）的简单赋值操作。copy 属性和strong一样也会持有一个对象的强引用。不同之处是存方法保留的是新值的不可变的副本。使用场景是对于像 NSString、NSArray、NSDictionary 等这样拥有可变子类的类，即使传入存方法的是它的一个可变子类对象，并在稍后对这个对象的值进行了修改也不会影响 copy 属性引用的对象。



术语：

线程-用于称呼代码执行的一条独立的路径。

进程-用于称呼一个正在运行的程序的实例，可以包含多个线程。